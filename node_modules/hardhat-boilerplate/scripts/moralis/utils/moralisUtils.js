const hre = require('hardhat');
const Moralis = require('moralis/node');
const joi = require('joi');

const utils = require('./utils');

function getMoralisSettings() {
  const schema = joi.object().keys({
    moralisSecret: joi.string().not().empty().required(),
    serverUrl: joi.string().not().empty().required(),
    appId: joi.string().not().empty().required(),
    masterKey: joi.string().not().empty().required(),
    delayRate: joi.number().required(),
    pageSize: joi.number().required(),
    queryLimit: joi.number().required(),
  });
  const { error } = schema.validate(hre.config.moralisSettings);
  if (error) throw new Error(error);
  return hre.config.moralisSettings;
}

module.exports.moralisSettings = getMoralisSettings;

module.exports.watchEvent = (topic, contractAddress, abiObject, tableName, syncHistorical) => {
  let options = {
    chainId: hre.network.config.chainId.toString(),
    address: contractAddress.toLowerCase(),
    topic: topic,
    abi: abiObject,
    limit: 500000,
    tableName: tableName,
    sync_historical: syncHistorical,
  };
  console.table(options);

  return Moralis.Cloud.run('watchContractEvent', options, { useMasterKey: true });
};

module.exports.unwatchEvent = (tableName) => {
  let options = {
    tableName: tableName,
  };
  console.table(options);
  return Moralis.Cloud.run('unwatchContractEvent', options, { useMasterKey: true });
};

/* This is uploading the data to IPFS folder. */
module.exports.bulkUploadToIpfs = async (ipfsArray) => {
  console.log('Uploading data to IPFS Folder...');
  let ipfsPaths;
  try {
    const result = await Moralis.Web3API.storage.uploadFolder({ abi: ipfsArray });
    console.table(result);
    ipfsPaths = utils.sortBy(result, 'path').map((asset, index) => ({ id: `${index + 1}`, ...asset }));
  } catch (error) {
    console.error(error);
    throw 'Upload failed, an error has occurred';
  }
  console.log('Data uploaded successfully!');
  return ipfsPaths;
};

/* This is updating the stage of the project. */
module.exports.updateStage = async (newStage, limit, options) => {
  console.log('Updating stage...');
  newStage = newStage.toLowerCase(); //just in case

  const query = new Moralis.Query('Stage');
  const result = await query.find(options);

  if (result.length > 1) throw 'ERROR: Invalid amount of stages';

  if (result.length === 0) {
    var nft = new Moralis.Object('Stage');
    await nft.save(
      {
        name: newStage,
        limit: limit,
        totalMinted: 0,
      },
      options,
    );
  } else {
    const stage = await query.get(result[0].id, options);
    stage.set('name', newStage);
    stage.set('limit', limit);
    await stage.save(null, options);
  }
  console.log(`Stage updated to <${newStage}> successfully!`);
};

module.exports.setGeneratedTickets = async (options) => {
  console.log('Setting GeneratedTickets table...');

  const query = new Moralis.Query('GeneratedTickets');
  const ticketCounter = await query.first(options);

  if (!ticketCounter) {
    var newTicketCounter = new Moralis.Object('GeneratedTickets');
    await newTicketCounter.save({ counter: 0 }, options);
  } else {
    ticketCounter.set('counter', 0);
    await ticketCounter.save(null, options);
  }
  console.log('GeneratedTickets table was set successfully!');
};

module.exports.setDiscordSettings = async (options) => {
  console.log('Setting DiscordServer table...');

  const { serverId, botId, botToken } = hre.config.discordSettings;

  const query = new Moralis.Query('DiscordServer');
  const currentSettings = await query.first(options);

  if (!currentSettings) {
    var newDiscordSetting = new Moralis.Object('DiscordServer');
    await newDiscordSetting.save(
      {
        discordServerID: serverId,
        discordBotID: botId,
        discordBotToken: botToken,
      },
      options,
    );
  } else {
    currentSettings.set('discordServerID', serverId);
    currentSettings.set('discordBotID', botId);
    currentSettings.set('discordBotToken', botToken);
    await currentSettings.save(null, options);
  }
  console.log('DiscordServer table was set successfully!');
};

/* This is downloading the whitelist for a specific stage. */
module.exports.getWhitelist = async (stage, options) => {
  const { queryLimit } = getMoralisSettings();
  console.log(`Downloading whitelist for stage ${stage}...`);
  stage = stage.toLowerCase(); //just in case

  const query = new Moralis.Query('Whitelist');
  query.equalTo('stage', stage);
  query.limit(queryLimit);
  const result = await query.find(options);

  if (result.length === 0) throw `ERROR: Whitelist ${stage} is empty`;

  console.log('Downloaded items:', result.length);
  return result.map((x) => ({ objectId: x.id, ...x.attributes }));
};

module.exports.getUsersDataAndTier = async () => {
  const whitelistQuery = new Moralis.Query('Whitelist');
  whitelistQuery.equalTo('stage', 'airdrop');
  const whitelistData = await whitelistQuery.aggregate([{ project: { address: 1, amount: 1, tier: 1 } }]);

  const query = new Moralis.Query('_User');
  query.containedIn(
    'ethAddress',
    whitelistData.map((x) => x.address),
  );
  query.limit(hre.config.moralisSettings.queryLimit ?? 10000); //max amount of records returned by moralis

  const users = await query.find({ useMasterKey: true });
  if (users.length === 0) return [];

  return users.map((x) => {
    const wlAddress = whitelistData.find((wl) => wl.address === x.attributes.ethAddress);
    return {
      ...x.attributes,
      amount: wlAddress.amount,
      tier: wlAddress.tier,
    };
  });
};

module.exports.getPartyUsers = async () => {
  const query = new Moralis.Query('Tickets').limit(300);

  const pipeline = [
    // join to _User collection on userAddress
    {
      lookup: {
        from: '_User',
        localField: 'userAddress',
        foreignField: 'ethAddress',
        as: 'user',
      },
    },
    // join to Whitelist collection on userAddress
    {
      lookup: {
        from: 'Whitelist',
        localField: 'userAddress',
        foreignField: 'address',
        as: 'whitelist',
      },
    },
    {
      project: {
        ticketNumber: 1,
        user: {
          firstName: 1,
          lastName: 1,
          fullName: 1,
          email: 1,
          city: 1,
          state: 1,
          country: 1,
          //ethAddress: 1,
        },
        whitelist: {
          amount: 1,
          stage: 1,
        },
      },
    },
  ];

  return query.aggregate(pipeline);
};

module.exports.initialize = async (options) => {
  console.log('Initializing Moralis Server Instance...');
  console.group();
  console.time('ServerConnection');

  const { serverUrl, appId, moralisSecret, masterKey } = getMoralisSettings();

  console.log('Server Url:', serverUrl);
  console.log('App Id:', appId);
  console.log('Moralis Secret:', moralisSecret);
  console.log('Master Key:', masterKey);
  console.log('Use Master Key:', options?.useMasterKey ?? false);

  //NOTE: I don't known why this lines doesn't work
  // const usedKey = options?.useMasterKey === true ? masterKey : moralisSecret;
  // await Moralis.start({ serverUrl, appId, usedKey });
  if (options?.useMasterKey === true) await Moralis.start({ serverUrl, appId, masterKey });
  else await Moralis.start({ serverUrl, appId, moralisSecret });

  utils.printElapsedTime('ServerConnection');

  console.groupEnd();
  console.log('Moralis Server Instance initialized!');
};

function processPage(holders, result) {
  for (const data of result) {
    const key = data.owner_of.toLowerCase();
    if (!holders[key]) holders[key] = 1;
    else holders[key] = holders[key] + 1;
  }
}

function assignTierAndAmountToHolders(holders) {
  for (const address in holders) {
    const holder = { amount: holders[address], tier: 1 };
    if (holder.amount > 19) {
      holder.tier = 3;
    } else if (holder.amount > 4) {
      holder.tier = 2;
    }
    holders[address] = holder;
  }
}

module.exports.downloadHolders = async () => {
  const holders = {};
  const contractAddress = '0xd78b76fcc33cd416da9d3d42f72649a23d7ac647';

  const { delayRate, pageSize } = getMoralisSettings();
  console.log('Downloading holders data ...');
  console.group();
  console.time('Download');
  console.log('Delay between requests:', delayRate);

  console.log('Page size:', pageSize);

  let cursor = null;
  do {
    await utils.sleep(delayRate);
    const response = await Moralis.Web3API.token.getNFTOwners({
      address: contractAddress,
      chain: 'eth',
      limit: pageSize,
      cursor: cursor,
    });
    console.log(
      `Processing page ${response.page} of ${Math.ceil(response.total / response.page_size)}, ${response.total} total`,
    );

    if (response.status === 'SYNCED' || response.status === 'COMPLETED') {
      processPage(holders, response.result);
    } else {
      console.log('===>', response.status);
      throw `Page number ${response.page} not SYNCED yet`;
    }
    cursor = response.cursor;
  } while (cursor != '' && cursor != null);

  console.log('Found holders:', Object.keys(holders).length);
  utils.printElapsedTime('Download');
  console.groupEnd();
  console.log('Download Finished!');
  console.log('Assigning Tier');
  assignTierAndAmountToHolders(holders);
  console.log('Finish');

  return holders;
};

module.exports.bulkUpload = async (tableName, tableData, options) => {
  console.log(`Uploading data to ${tableName}...`);
  console.time(`Upload on ${tableName}`);
  const result = await Moralis.Cloud.run(
    'bulkInsert',
    {
      tableName: tableName,
      tableData: tableData,
    },
    options,
  );
  console.timeEnd(`Upload on ${tableName}`);
  console.log('Inserted records:', result.insertedCount);
};

module.exports.bulkDelete = async (tableName, filters, options) => {
  console.log(`Bulk delete on ${tableName}...`);
  console.time(`Delete on ${tableName}`);
  const result = await Moralis.Cloud.run(
    'bulkDelete',
    {
      tableName: tableName,
      filters: filters,
    },
    options,
  );
  console.timeEnd(`Delete on ${tableName}`);
  console.log('Deleted records:', result.deletedCount);
};

async function bulkUpdateMany(tableName, updatedData, options) {
  console.log(`Bulk update on ${tableName}...`);
  console.time(`Update on ${tableName}`);
  const result = await Moralis.Cloud.run(
    'bulkUpdate',
    {
      tableName: tableName,
      updatedData: updatedData,
    },
    options,
  );
  console.log('Updated records:', result.modifiedCount);
  console.timeEnd(`Update on ${tableName}`);
}

module.exports.bulkUpdateMany = bulkUpdateMany;

module.exports.getNFTs = (address, amount) => {
  return Moralis.Cloud.run('getNFTs', {
    address: address,
    amount: amount,
  });
};

module.exports.getDistinctWalletsWithNftsCount = (wallets) => {
  return Moralis.Cloud.run('getWalletsWithNFTsCount', {
    addresses: wallets,
  });
};

module.exports.splitFullName = async (options) => {
  const query = new Moralis.Query('_User');
  query.exists('fullName');
  query.doesNotExist('firstName');
  query.limit(10000);

  const users = await query.find({ useMasterKey: true });
  if (users.length === 0) return [];

  const usersToUpdate = [];

  for (const user of users) {
    let names = user.attributes.fullName.trim().split(' ');
    let lastName = '';
    const hasLastName = names.length > 1;
    if (hasLastName) {
      lastName = names.splice(names.length - 1).join();
    }
    let firstName = names.join(' ');

    usersToUpdate.push({ filter: { objectId: user.id }, update: { firstName, lastName } });
  }

  await bulkUpdateMany('_User', usersToUpdate, options);
};
