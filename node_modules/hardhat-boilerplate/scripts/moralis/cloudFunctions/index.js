const useMasterKey = { useMasterKey: true };

const STAGE_NAME = {
  TICKETS: 'party',
};

const TOTAL_MINTED_LIMIT = {
  TICKETS: 155,
  TOKENS: 7777,
};

class WrongStageException {
  message = 'The current stage is invalid.';
}

class UserNotFoundException {
  message = 'The UserAddress was not found';
}

class StageNotFoundException {
  message = 'The stage was not found.';
}

class MoreThanOneStageException {
  message = 'The stage was defined more than once.';
}

class NotAllowedException {
  message = 'Not Allowed.';
}

class TicketGenerationException {
  message = 'Error on ticket generation. Please, try again.';
}

class DiscordSettingsNotFoundException {
  message = 'No Discord settings found.';
}

class SendgridApiUrlException {
  message = 'Sendgrid API URL is not configured.';
}

class SendgridApiKeyException {
  message = 'Sendgrid API key is not configured.';
}

class SendgridListIdException {
  message = 'Sendgrid newsletter list ID is not configured.';
}

class SoldOutException {
  message = 'Tickets for the party are sold out.';
}
class NotWhitelistedException {
  message = 'The user is not whitelisted.';
}

class ExceedLimitException {
  message = 'Tickets claim limit exceeded.';
}

class EmailRequiredException {
  message = 'Email is required.';
}

class EmailAlreadyExistsException {
  message = 'Email already exists.';
}

class WrongAssetsException {
  message = 'Invalid asset quantity.';
}

class UserExistsException {
  message = 'User already exists.';
}

/* Returns the current stage */
const getCurrentStage = async () => {
  const query = new Moralis.Query('Stage');
  const result = await query.find(useMasterKey);
  if (result.length === 0) throw new StageNotFoundException();
  if (result.length > 1) throw new MoreThanOneStageException();
  return result[0];
};

/* Returns the name for current stage */
const getCurrentStageName = async () => {
  const stage = await getCurrentStage();
  return stage.attributes.name;
};

/* Returns a Query object for specific address in current stage */
const getAddressInfoForCurrentStage = async (address) => {
  const currentStageName = await getCurrentStageName();
  const query = new Moralis.Query('Whitelist');
  query.equalTo('address', address);
  query.equalTo('stage', currentStageName);
  const result = await query.find(useMasterKey);
  return result.length === 0 ? null : result[0];
};

/* ONLY USED FOR SCRIPT AND TEST: executes a bulk insert in the specified table with specified data*/
Moralis.Cloud.define(
  'bulkInsert',
  async (request) => {
    return Moralis.bulkWrite(request.params.tableName, request.params.tableData);
  },
  {
    requireMaster: true,
  },
);
/* ONLY USED FOR SCRIPT AND TEST: executes a bulk insert in the specified table with specified data*/
Moralis.Cloud.define(
  'bulkUpdate',
  async (request) => {
    return Moralis.bulkUpdateMany(request.params.tableName, request.params.updatedData);
  },
  {
    requireMaster: true,
  },
);

/* ONLY USED FOR SCRIPT AND TEST: executes a bulk delete in the specified table with specified data*/
Moralis.Cloud.define(
  'bulkDelete',
  async (request) => {
    return Moralis.bulkDeleteMany(request.params.tableName, request.params.filters);
  },
  {
    requireMaster: true,
  },
);

const getAlreadyMintedAmount = async (address, stageName) => {
  const query = new Moralis.Query('MintedTokens');
  query.equalTo('owner', address);
  query.equalTo('stage', stageName);
  const alreadyMintedResults = await query.distinct('tokenIds');
  return alreadyMintedResults.length;
};

const getAvailableAmountToMintByTransaction = (alreadyMintedAmount, availableAmountToMint, stage) => {
  const stageLimit = stage.attributes.limit;
  if (isCurrentStageGiveaway(stage.attributes.name)) {
    return availableAmountToMint / stageLimit > 1 ? stageLimit : availableAmountToMint;
  }
  return stageLimit - alreadyMintedAmount;
};

const isCurrentStageGiveaway = (currentStageName) => currentStageName === 'giveaway';

/* Returns a boolean result if address can get giveaway tokens in the current stage*/
Moralis.Cloud.define(
  'amIWhitelisted',
  async (request) => {
    const userAddress = request.user.get('ethAddress');
    const currentStage = await getCurrentStage();
    const currentStageName = currentStage.attributes.name;
    const isSoldOut = currentStage.attributes.totalMinted === TOTAL_MINTED_LIMIT.TOKENS;

    const addressInfo = await getAddressInfoForCurrentStage(userAddress);

    const isOpenSaleStage = currentStageName === 'opensale';
    const amIWhitelisted = isOpenSaleStage ? true : addressInfo !== null;

    const alreadyMintedAmount = await getAlreadyMintedAmount(userAddress, currentStage.attributes.name);

    const holdAmount = amIWhitelisted && !isOpenSaleStage ? addressInfo.attributes.amount ?? 0 : 0;
    const availableToMint = holdAmount - alreadyMintedAmount;
    const availableAmountToMintByTransaction = getAvailableAmountToMintByTransaction(
      alreadyMintedAmount,
      availableToMint,
      currentStage,
    );
    const availableAmountToMint = isCurrentStageGiveaway(currentStageName)
      ? availableToMint
      : availableAmountToMintByTransaction;
    return {
      amIWhitelisted,
      signature: amIWhitelisted && !isOpenSaleStage ? addressInfo.attributes.signature ?? '' : '',
      proofFor: amIWhitelisted && !isOpenSaleStage ? addressInfo.attributes.hexProof ?? '' : [],
      isSoldOut,
      holdAmount,
      alreadyMintedAmount,
      availableAmountToMintByTransaction,
      availableAmountToMint,
      stageLimit: currentStage.attributes.limit,
    };
  },
  {
    requireUser: true,
  },
);

Moralis.Cloud.define('getStage', async (request) => {
  const currentStage = await getCurrentStageName();
  return currentStage;
});

Moralis.Cloud.beforeSaveFile((request) => {
  throw new NotAllowedException();
});

const logger = Moralis.Cloud.getLogger();

const logError = (functionName, error) => {
  logger.error(`${functionName} - Got an error: ${error?.message ?? error}`);
};

Moralis.Cloud.afterSave('MintedTokens', async (request) => {
  try {
    const confirmed = request.object.get('confirmed');
    const stage = await getCurrentStage();

    const query = new Moralis.Query('MintedTokens');
    const mintedTokenIds = await query.distinct('tokenIds');
    stage.set('totalMinted', mintedTokenIds.length);
    await stage.save(null, useMasterKey);

    if (confirmed) {
      const userAddress = request.object.get('owner');
      const tokenIds = request.object.get('tokenIds');
      await sendMintNotificationEmail(userAddress, tokenIds.length);
    }
  } catch (error) {
    logError('MintedTokens', error);
  }
});

const getVillainByTokenId = async (tokenId) => {
  const query = new Moralis.Query('Villains');
  query.equalTo('tokenId', tokenId);
  const result = await query.find(useMasterKey);
  return result.length === 0 ? null : result[0];
};

const updateOwnerToVillain = async (villain, newOwner) => {
  villain.set('owner', newOwner);
  await villain.save(null, useMasterKey);
};

const createVillainOwner = async (tokenId, newOwner) => {
  var newVillainOwner = new Moralis.Object('Villains');
  await newVillainOwner.save(
    {
      owner: newOwner,
      tokenId: tokenId,
    },
    useMasterKey,
  );
};

const createOrUpdateVillainOwner = async (tokenId, newOwner) => {
  const villain = await getVillainByTokenId(tokenId);
  if (villain) {
    await updateOwnerToVillain(villain, newOwner);
  } else {
    await createVillainOwner(tokenId, newOwner);
  }
};

Moralis.Cloud.afterSave('VillainsTransfers', async (request) => {
  try {
    const confirmed = request.object.get('confirmed');
    if (confirmed) {
      const tokenId = request.object.get('tokenId');
      const newOwner = request.object.get('to');
      await createOrUpdateVillainOwner(tokenId, newOwner);
    }
  } catch (error) {
    logError('VillainsTransfers', error);
  }
});

Moralis.Cloud.define('getMetadata', async (request) => {
  return {
    description: 'A collection of 7,777 Lil Villains Plans',
    image: 'https://as1.ftcdn.net/v2/jpg/00/99/82/88/1000_F_99828865_lW5dIHE9e4NCI8Lb5XaY4wL5CL32hiAI.jpg',
    name: `#${request.params.tokenId}`,
    attributes: [
      { trait_type: 'Hat', value: 'none' },
      { trait_type: 'Eyes', value: 'none' },
      { trait_type: 'Ears', value: 'none' },
      { trait_type: 'Mouth', value: 'none' },
      { trait_type: 'Nose', value: 'none' },
      { trait_type: 'Hair', value: 'none' },
      { trait_type: 'Helmet', value: 'none' },
      { trait_type: 'Clothes', value: 'none' },
      { trait_type: 'Skin', value: 'none' },
      { trait_type: 'Back', value: 'none' },
      { trait_type: 'Background', value: 'none' },
    ],
  };
});

// Moralis.Cloud.define('getProvenance', async (request) => {
//   let visibleColumns = { tokenId: 1, hash: 1, _id: 0 };

//   const includeIPFSHash = (await getCurrentStageName()) === 'reveal';
//   if (includeIPFSHash) visibleColumns = { IPFSHash: 1, ...visibleColumns };

//   const query = new Moralis.Query('Villains');

//   const provenanceData = await query.aggregate([{ project: visibleColumns }]);
//   return { provenance: provenanceData };
// });

const assignTicket = (userAddress, ticketNumber) => {
  const newUserTicket = new Moralis.Object('Tickets');
  return newUserTicket.save(
    {
      userAddress: userAddress,
      ticketNumber: ticketNumber,
    },
    useMasterKey,
  );
};

const createTicketForUser = async (userAddress) => {
  const generatedTicketDocument = await getGeneratedTicketsDocument();
  generatedTicketDocument.increment('counter');

  const newGeneratedTicketDocument = await generatedTicketDocument.save(null, useMasterKey);
  if (!newGeneratedTicketDocument) throw new TicketGenerationException();

  const ticketNumber = (97 * newGeneratedTicketDocument.attributes.counter + 677) % 9999;
  await assignTicket(userAddress, ticketNumber);
  return ticketNumber;
};

const getTicketNumberByAddress = async (userAddress) => {
  const query = new Moralis.Query('Tickets');
  query.equalTo('userAddress', userAddress);
  const userTicket = await query.first(useMasterKey);

  let ticketNumber = 0;
  if (userTicket) ticketNumber = userTicket.attributes.ticketNumber;

  return ticketNumber;
};

const getGeneratedTicketsDocument = () => {
  const query = new Moralis.Query('GeneratedTickets');
  return query.first(useMasterKey);
};

const isWhitelisted = async (userAddress) => {
  const addressInfo = await getAddressInfoForCurrentStage(userAddress);
  return addressInfo !== null;
};

const isPartyStageSoldOut = async () => {
  const generatedTicketsDocument = await getGeneratedTicketsDocument();
  return generatedTicketsDocument.attributes.counter === TOTAL_MINTED_LIMIT.TICKETS;
};

Moralis.Cloud.define(
  'getMyTicketNumber',
  async (request) => {
    const currentStage = await getCurrentStage();
    if (currentStage.attributes.name !== STAGE_NAME.TICKETS) {
      throw new WrongStageException();
    }

    const userAddress = request.user.get('ethAddress');
    const amIWhitelisted = await isWhitelisted(userAddress);
    const isSoldOut = await isPartyStageSoldOut();
    const ticketNumber = amIWhitelisted ? await getTicketNumberByAddress(userAddress) : 0;

    return {
      amIWhitelisted,
      alreadyClaimed: !!ticketNumber,
      ticketNumber: ticketNumber,
      isSoldOut,
    };
  },
  {
    requireUser: true,
  },
);

Moralis.Cloud.define(
  'postMyTicketNumber',
  async (request) => {
    const currentStage = await getCurrentStage();
    if (currentStage.attributes.name !== STAGE_NAME.TICKETS) {
      throw new WrongStageException();
    }

    const userAddress = request.user.get('ethAddress');
    const amIWhitelisted = await isWhitelisted(userAddress);
    if (!amIWhitelisted) {
      throw new NotWhitelistedException();
    }

    // TODO: Move this to a Before Save to improve security

    const isSoldOut = await isPartyStageSoldOut();
    if (isSoldOut) {
      throw new SoldOutException();
    }

    // TODO: Move this to a Before Save to improve security

    const alreadyClaimed = (await getTicketNumberByAddress(userAddress)) !== 0;
    if (alreadyClaimed) {
      throw new ExceedLimitException();
    }

    const ticketNumber = await createTicketForUser(userAddress);

    return {
      amIWhitelisted: true,
      alreadyClaimed: true,
      ticketNumber: ticketNumber,
    };
  },
  {
    requireUser: true,
  },
);

const baseUrl = 'https://discord.com/api/v9/';
const ticketUrl = 'https://test-tickets.lilvillains.io/claim-your-ticket';

const getNewDiscordRequest = ({ method, endpoint, body, discordSettings }) => {
  return {
    method: method,
    url: `${baseUrl}${endpoint}`,
    headers: {
      'Content-Type': 'application/json;charset=utf-8',
      Authorization: `Bot ${discordSettings.discordBotToken}`,
      'User-Agent': 'DiscordBot (https://discord.js.org, 13.7.0)',
    },
    body: body,
  };
};

const parseDiscordUsername = (discordUsername) => {
  const values = discordUsername.trim().split('#');
  if (values.length !== 2) throw `ParseDiscordUsername: invalid discord username '${discordUsername}'`;
  return {
    username: values[0],
    discriminator: values[1],
  };
};

const getDiscordUser = async (discordUsername, discordSettings) => {
  const parsedUsername = parseDiscordUsername(discordUsername);
  //We only process the first 100 same usernames
  const getDiscordUserEndpoint = `guilds/${discordSettings.discordServerID}/members/search?query=${parsedUsername.username}&limit=100`;
  const req = getNewDiscordRequest({ method: 'GET', endpoint: getDiscordUserEndpoint, discordSettings });
  const response = await Moralis.Cloud.httpRequest(req);
  const foundMemberUsers = response && response.status === 200 && response.data.length > 0 ? response.data : null;
  return foundMemberUsers?.find((memberUser) => memberUser.user.discriminator === parsedUsername.discriminator)?.user;
};

const createDM = async (userDiscordID, discordSettings) => {
  const postCreateDMEndpoint = `users/${discordSettings.discordBotID}/channels`;
  const body = { recipient_id: userDiscordID };
  const req = getNewDiscordRequest({ method: 'POST', endpoint: postCreateDMEndpoint, body, discordSettings });
  const response = await Moralis.Cloud.httpRequest(req);
  return response && response.status === 200 ? response.data : null;
};

const sendTicketNotification = async (dmID, ticketNumberAssigned, discordSettings) => {
  const message = {
    content: `Congratulations! You already have your ticket No: **${ticketNumberAssigned}** for the party!`,
  };
  const getDiscordUserEndpoint = `channels/${dmID}/messages`;
  const req = getNewDiscordRequest({
    method: 'POST',
    endpoint: getDiscordUserEndpoint,
    body: message,
    discordSettings,
  });
  const response = await Moralis.Cloud.httpRequest(req);
  return response && response.status === 200 ? response.data : null;
};

const getDiscordSettings = async () => {
  const query = new Moralis.Query('DiscordServer');
  const discordServerInformation = await query.first(useMasterKey);
  return discordServerInformation?.attributes;
};

Moralis.Cloud.afterSave('Tickets', async (request) => {
  try {
    const discordSettings = await getDiscordSettings();
    if (!discordSettings) throw new DiscordSettingsNotFoundException();

    const userAddress = request.object.get('userAddress');

    const moralisUser = await getMoralisUserOrFail(userAddress);

    const discordUser = await getDiscordUser(moralisUser.attributes.discordUsername, discordSettings);
    if (!discordUser) throw `Invalid discord username: ${moralisUser.attributes.discordUsername}(${userAddress})`;

    const dm = await createDM(discordUser.id, discordSettings);
    if (!dm) throw `Can not create DM message to user: ${moralisUser.attributes.discordUsername}(${discordUser.id})`;

    const ticketNumberAssigned = await getTicketNumberByAddress(userAddress);
    const result = await sendTicketNotification(dm.id, ticketNumberAssigned, discordSettings);
    if (!result)
      throw `Error sending notification to user: ${moralisUser.attributes.discordUsername}(${discordUser.id})`;
  } catch (error) {
    logError('TicketsNotification', error);
  }
});

const getMoralisUserOrFail = async (userAddress) => {
  if (!userAddress) throw new UserNotFoundException();
  const query = new Moralis.Query('_User');
  query.equalTo('ethAddress', userAddress);
  const user = await query.first(useMasterKey);
  if (!user) throw `User address: '${userAddress}' not exists in _User`;
  return user;
};

const getMoralisUserByEmail = async (email) => {
  const query = new Moralis.Query('_User');
  query.equalTo('email', email);
  return query.first(useMasterKey);
};

/* Profile */

Moralis.Cloud.define(
  'getUserProfile',
  async (request) => {
    const userAddress = request.user.get('ethAddress');

    const user = await getMoralisUserOrFail(userAddress);
    const userEmail = user.attributes.email;
    const contactId = userEmail ? await getSendgridContact(userEmail) : undefined;

    return {
      email: userEmail,
      newsletterSubscribed: !!contactId,
    };
  },
  {
    requireUser: true,
  },
);

const createEnrollmentAssets = async (userAddress, quantityLilVillains, quantityLilHeroes) => {
  var newEnrollment = new Moralis.Object('Enrollment');
  await newEnrollment.save(
    {
      userAddress: userAddress,
      lilVillainsAmount: quantityLilVillains,
      lilHeroesAmount: quantityLilHeroes,
    },
    useMasterKey,
  );
};

const getEnrollmentUser = async (userAddress) => {
  if (!userAddress) throw new UserNotFoundException();
  const query = new Moralis.Query('Enrollment');
  query.equalTo('userAddress', userAddress);
  const user = await query.first(useMasterKey);
  return user;
};

Moralis.Cloud.define(
  'postEnrollment',
  async (request) => {
    const userAddress = request.user.get('ethAddress');
    const lilVillainsAmount = request.params.lilVillainsAmount;
    const lilHeroesAmount = request.params.lilHeroesAmount;

    if (lilVillainsAmount !== lilHeroesAmount) {
      throw new WrongAssetsException();
    }

    const userWithEnrollment = await getEnrollmentUser(userAddress);

    if (userWithEnrollment != null) {
      throw new UserExistsException();
    }

    // TODO: validate web3

    await createEnrollmentAssets(userAddress, lilVillainsAmount, lilHeroesAmount);

    return {
      success: true,
    };
  },
  {
    requireUser: true,
    fields: {
      lilVillainsAmount: {
        required: true,
        type: Number,
        options: (val) => {
          return val && val > 0;
        },
        error: 'WRONG_AMOUNT: lilVillainsAmount',
      },
      lilHeroesAmount: {
        required: true,
        type: Number,
        options: (val) => {
          return val && val > 0;
        },
        error: 'WRONG_AMOUNT: lilHeroesAmount',
      },
    },
  },
);

/* This configuration is required to avoid timeouts when we use Moralis Web3APIs */
Moralis.settings.setAPIRateLimit({
  anonymous: 100, //requests
  authenticated: 200, //requests
  windowMs: 60000, //request window
});
