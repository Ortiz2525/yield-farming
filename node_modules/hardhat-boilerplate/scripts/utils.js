const hre = require('hardhat');
const os = require('os');
const fs = require('fs');
const path = require('path');
const joi = require('joi');

const whitelist = require('./moralis/setWhitelist');
const signature = require('./moralis/setSignature');
const merkle = require('./moralis/setMerkleTree');

const SPLIT_CHAR = process.env.CSV_SEPARATOR !== 'comma' ? ';' : ',';

function getContractsAddressesSettings() {
  const schema = joi.object().keys({
    minter: joi.string().length(42).required(),
    collection: joi.string().length(42).required(),
  });
  const { error } = schema.validate(hre.config.contractsAddresses);
  if (error) throw new Error(error);

  return hre.config.contractsAddresses;
}
function getDeploySettings() {
  const schema = joi.object().keys({
    royaltySettings: joi.object().keys({
      address: joi.string().length(42).required(),
      percentage: joi.number().greater(0).max(1000).required(),
    }),
    signerSettings: joi.object().keys({
      domainName: joi.string().required(),
      domainVersion: joi.string().required(),
    }),
    chainlinkSettings: joi.object().keys({
      subscriptionId: joi.number().greater(0).required(),
      coordinator: joi.string().length(42).required(),
      keyHash: joi.string().length(66).required(),
    }),
    villainsSettings: joi.object().keys({
      baseUri: joi.string().required(),
      description: joi.string().required(),
    }),
  });
  const { error } = schema.validate(hre.config.deploySettings);
  if (error) throw new Error(error);

  return hre.config.deploySettings;
}

const stageSchema = joi.object().keys({
  name: joi.string().not().empty().required(),
  price: joi.string().not().empty().required(),
  maxAmount: joi.number().greater(0).required(),
  useWhitelist: joi.bool().required(),
  whitelistFilePath: joi.string().optional(),
});

function getStageSettings(stageName) {
  const stages = hre.config.stages;
  if (!stages) throw new Error('hre.config.stages must be defined');
  const stage = stages[stageName];
  const { error } = stageSchema.validate(stage);
  if (error) throw new Error(error);
  return stage;
}

module.exports = {
  getDeploySettings,
  getContractsAddressesSettings,
  getGiveawaySettings: () => getStageSettings('giveaway'),
  getPresaleSettings: () => getStageSettings('presale'),
  getOpensaleSettings: () => getStageSettings('opensale'),
  setSignatures: async () => {
    console.log('-------------Setting signatures giveaway whitelist-------------'.green);
    console.group();
    const { minter } = getContractsAddressesSettings();
    const { signerSettings } = getDeploySettings();
    await signature.setSigns(minter, signerSettings);
    console.groupEnd();
    console.log('-------------Signatures to giveaway whitelist was set successfully-------------'.green);
  },
  setWhitelist: async (stageName) => {
    console.log(`-------------Setting ${stageName} holders whitelist-------------`.green);
    console.group();
    await whitelist.main(stageName);
    console.groupEnd();
    console.log(`-------------${stageName} holders whitelist was set successfully-------------`.green);
  },
  addRecordsToWhitelist: async (stageName, extraRecords) => {
    console.log(`-------------Adding records to ${stageName} whitelist-------------`.green);
    console.group();
    await whitelist.addRecordsToWhitelist(stageName, extraRecords);
    console.groupEnd();
    console.log(`-------------Records added to ${stageName} whitelist successfully-------------`.green);
  },
  buildMerkleTreeFor: async (stageName) => {
    console.log(`-------------Building merkle tree for stage ${stageName}-------------`.green);
    console.group();
    const rootHash = await merkle.buildFor(stageName);
    console.groupEnd();
    console.log('-------------Merkle tree was created successfully-------------'.green);
    return rootHash;
  },
  getCustomWhitelistFromFile: (stageName, filePath, ignoreAmount) => {
    console.log('-------------Loading custom whitelist-------------'.green);
    console.group();
    const data = fs.readFileSync(filePath, 'utf-8');
    const addresses = [];
    data.split(os.EOL).forEach((line) => {
      if (line) {
        const values = line.split(SPLIT_CHAR);
        if (values.length !== 2) throw `${filePath} has invalid values! [row format =>(address,amount)]`;
        const amount = ignoreAmount ? 0 : +values[1];
        addresses.push({
          update: {
            //adapted to moralis bulkInsert
            address: values[0].toLowerCase(),
            amount: amount,
            tier: 0,
            stage: stageName,
          },
        });
      }
    });
    console.log('Found addresses:', addresses.length);
    console.groupEnd();
    console.log('-------------Custom whitelist loaded successfully-------------'.green);
    return addresses;
  },
  generateOutput: (contract, contractName) => {
    if (!fs.existsSync(hre.config.outputData)) {
      fs.mkdirSync(hre.config.outputData, { recursive: true });
    }
    const contractDataPath = path.resolve(hre.config.paths.root, hre.config.outputData, contractName);
    if (fs.existsSync(contractDataPath)) fs.unlinkSync(contractDataPath);

    const contractData = {
      address: contract.address,
      abi: JSON.parse(contract.interface.format(hre.ethers.utils.FormatTypes.json)),
    };

    fs.writeFileSync(contractDataPath, `${JSON.stringify(contractData, null, config.spacing)}\n`, { flag: 'w' });
  },
};
